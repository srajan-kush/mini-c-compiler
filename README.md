# Frontend Phase of a C Compiler

## Team Members
- Krishnakant Dinkar
- Srajan Kushwaha

## Using the Compiler

```
lex lexer.l
yacc -d -v parser.y
gcc -w y.tab.c -o parser
./parser < input1.c
```

## Flow:

Lexical Analysis: Populate symbol_table using add().

Syntax Analysis: Build and print the parse tree.

Semantic Analysis: Check for errors (undeclared vars, type mismatches).

Intermediate Code: Generate and print ICG instructions.

## Screenshots

Below are the output screenshots of the compiler:

- `icg.png`
- `inorder.png`
- `semantic.png`
- `table.png`
- `tree.png`

## Header Section (%{ ... %})
This section includes:

- Standard libraries (stdio.h, stdlib.h, string.h, ctype.h)
- Lexer file (lex.yy.c): This file is typically generated by Lex/Flex, which provides tokenization (breaking source code into tokens).
- Function prototypes:
  - yyerror(const char *s): Handles syntax errors.
  - yylex(): Calls the lexer (from lex.yy.c) to get the next token.
  - yywrap(): Handles the end of file condition in lex.yy.c.
  - add(char c): Adds an identifier, keyword, or function to the symbol table.
  - insert_type(): Assigns data types to identifiers.
  - search(char *name): Searches for an identifier in the symbol table.
  - check_declaration(char *name): Ensures variables are declared before use.
  - check_return_type(char *name): Ensures function return types match.
  - check_types(char *a, char *b): Ensures type compatibility in operations.
  - get_type(char *name): Returns the type of an identifier.
  - mknode(struct node *left, struct node *right, char *token): Constructs syntax tree nodes.

## Symbol Table (symbol_table[40])

Stores variable names, data types, and types (e.g., function, keyword, variable).

## Syntax Tree (struct node)

Used for Abstract Syntax Tree (AST) generation.
Each node represents an operator, operand, or control structure.

## Intermediate Code Generation (icg)

Stores Intermediate Code instructions.

## What is LEX?

LEX is a tool used to generate a lexical analyzer. The input is a set of regular expressions in addition to actions. The output is a table-driven scanner called lex.yy.c.

## What is YACC?

YACC (Yet Another Compiler Compiler) is a tool used to generate a parser. It parses the input file and does semantic analysis on the stream of tokens produced by the LEX file. YACC translates a given Context-Free Grammar (CFG) specification into a C implementation y.tab.c. This C program, when compiled, yields an executable parser.

## Features of the Compiler

- Symbol Table
- Parse Tree and AST
- Semantic Analysis
- Intermediate Code Generation

## What the Compiler Accepts

- Simple C programs - declaration and assignment, printf, scanf, and arithmetic operations (+, -, *, /)
- Simple for loops and if-else statements (no else if)
- Nested for loops and if-else statements

### Assumptions

- All header files are of the format "^"#include"[ ]*<.+\.h>".
- The main function does not take any input parameters.
- Numbers follow the format "[-]?{digit}+| [-]?{digit}+\.{digit}{1,6}". Hence numbers of the type +123.45 are not permitted.
- The variables can be of int, float, or char type. No arrays are permitted.
- The body of an if and else block is enclosed in parentheses even if it is a single line.
- The body of a for loop is enclosed in parentheses, even if it is a single line.
- For simplicity, the scope of all variables is considered the same. Hence, variables cannot be redeclared within loops or if-else blocks.
- `printf` statements take a single string as a parameter. No type checking is performed.
- `scanf` statements take a string and &id as input. No type checking is performed.
- The condition statement of an if statement and for statement is of the form "value relop value" where value can be a number or id.

## Phases of the Compiler

The final parser takes a C program with nested for loops or if-else blocks and performs lexical, syntax, and semantic analysis, followed by intermediate code generation.

### Lexer and Context-Free Grammar

The first step was to code the lexer file to take the stream of characters from the input programs and identify the tokens defined with the help of regular expressions. Next, the YACC file was created, which contained the context-free grammar that accepts a complete C program constituting headers, the main function, variable declarations and initializations, nested for loops, if-else constructs, and expressions of the form of binary arithmetic and unary operations.

### Lexical Analysis

A struct was defined with the attributes id_name, data_type (int, float, char, etc.), type (keyword, identifier, constant, etc.), and line_no to generate a symbol table. The symbol table is an array of the above-defined struct. Whenever the program encounters a header, keyword, constant, or variable declaration, the `add` function is called, which takes the type of the symbol as a parameter.

### Syntax Analysis

For syntax analysis, a struct was declared to represent the node for the binary tree that is to be generated. The struct node has attributes left, right, and a token, which is a character array. To generate the syntax tree, a node is created for each token and linked to the nodes of the tokens, which occur to its left and right semantically.

### Semantic Analysis

The semantic analyzer handles three types of static checks:
1. Variables should be declared before use.
2. Variables cannot be redeclared.
3. Type checking of variables in an arithmetic expression.

### Intermediate Code Generation

For intermediate code generation, the three-address code representation was used. Variables were used to keep track of the next temporary variable and label to be generated. The condition statements of `if` and `for` were also declared to store the labels to `goto` in case the condition is satisfied or not satisfied.

## Example of the Compiler in Action

```
#include<stdio.h>
#include<string.h>

int main() {
    int a;
    int x=1;
    int y=2;
    int z=3;
    x=3;
    y=10;
    z=5;
    if(x>5) {
        for(int k=0; k<10; k++) {
            y = x+3;
            printf("Hello!");
        }
    } else {
        int idx = 1;
    }
    for(int i=0; i<10; i++) {
        printf("Hello World!");
        scanf("%d", &x);
        if (x>5) {
            printf("Hi");
        }
        for(int j=0; j<z; j++) {
            a=1;
        }
    }
    return 1;
}
```

